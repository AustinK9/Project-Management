# import libraries
import sys
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel,
    QLineEdit, QPushButton, QComboBox, QListWidget, QFileDialog,
    QDateEdit, QMessageBox, QFormLayout, QFrame
)
from PyQt5.QtCore import QDate, Qt
from PyQt5.QtGui import QColor
import matplotlib.pyplot as plt
from matplotlib.patches import Patch
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.lines import Line2D
import pandas as pd
from datetime import datetime

# class creation for all that goes in the Gantt Chart App
class GanttChartApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Gantt Chart Task Manager")
        
        self.setGeometry(100, 100, 1000, 1200)

        self.tasks = []
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout()

        # Form for task input
        form_layout = QFormLayout()
        self.name_input = QLineEdit()
        self.gantt_name_input = QLineEdit()

        self.start_date_input = QDateEdit()
        self.start_date_input.setCalendarPopup(True)
        self.start_date_input.setDate(QDate.currentDate())

        self.end_date_input = QDateEdit()
        self.end_date_input.setCalendarPopup(True)
        self.end_date_input.setDate(QDate.currentDate())

        self.priority_input = QComboBox()
        self.priority_input.addItems(["High", "Medium", "Low"])
        self.priority_input.setCurrentText("Medium")

        self.status_input = QComboBox()
        self.status_input.addItems(["Not Started", "In Progress", "Completed"])
        self.status_input.setCurrentText("Not Started")

        form_layout.addRow("Task Name:", self.name_input)
        form_layout.addRow("Gantt Chart Name:", self.gantt_name_input)
        form_layout.addRow("Start Date:", self.start_date_input)
        form_layout.addRow("End Date:", self.end_date_input)
        form_layout.addRow("Priority:", self.priority_input)
        form_layout.addRow("Status:", self.status_input)

        main_layout.addLayout(form_layout)

        # Buttons
        btn_layout = QHBoxLayout()
        self.add_btn = QPushButton("Add / Update Task")
        self.add_btn.clicked.connect(self.add_task)

        self.edit_btn = QPushButton("Edit Selected")
        self.edit_btn.clicked.connect(self.edit_task)

        self.delete_btn = QPushButton("Delete Selected")
        self.delete_btn.clicked.connect(self.delete_task)

        self.clear_btn = QPushButton("Clear Fields")
        self.clear_btn.clicked.connect(self.clear_inputs)

        btn_layout.addWidget(self.add_btn)
        btn_layout.addWidget(self.edit_btn)
        btn_layout.addWidget(self.delete_btn)
        btn_layout.addWidget(self.clear_btn)
        main_layout.addLayout(btn_layout)

        # Task List
        self.task_list = QListWidget()
        self.task_list.setDragDropMode(QListWidget.InternalMove)
        self.task_list.model().rowsMoved.connect(self.on_rows_moved)
        self.task_list.setMinimumHeight(120)
        self.task_list.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.task_list.setMinimumHeight(200)
        self.task_list.itemDoubleClicked.connect(self.edit_task)
        main_layout.addWidget(QLabel("Tasks:"))
        main_layout.addWidget(self.task_list)     

        # Chart
        self.figure, self.ax = plt.subplots(figsize=(10, 5))
        self.canvas = FigureCanvas(self.figure)
        main_layout.addWidget(self.canvas)

        # Bottom bar
        bottom_btns = QHBoxLayout()
        self.save_csv_btn = QPushButton("üíæ Save to CSV")
        self.save_csv_btn.clicked.connect(self.save_to_csv)

        self.load_csv_btn = QPushButton("üìÇ Load from CSV")
        self.load_csv_btn.clicked.connect(self.load_from_csv)

        self.export_chart_btn = QPushButton("üì§ Export Chart as PNG")
        self.export_chart_btn.clicked.connect(self.export_chart)

        self.exit_btn = QPushButton("‚ùå Exit")
        self.exit_btn.clicked.connect(self.close)

        bottom_btns.addWidget(self.save_csv_btn)
        bottom_btns.addWidget(self.load_csv_btn)
        bottom_btns.addWidget(self.export_chart_btn)
        bottom_btns.addWidget(self.exit_btn)

        main_layout.addLayout(bottom_btns)
        self.setLayout(main_layout)
        self.draw_gantt_chart()
 
    # define color priority for tasks
    def priority_color(self, priority):
        return {
            "High": "red",
            "Medium": "orange",
            "Low": "green"
        }.get(priority, "gray")

    # add a task
    def add_task(self):
        name = self.name_input.text().strip()
        if not name:
            QMessageBox.warning(self, "Input Error", "Task name cannot be empty.")
            return

        start = self.start_date_input.date().toPyDate()
        end = self.end_date_input.date().toPyDate()
        if end < start:
            QMessageBox.warning(self, "Date Error", "End date cannot be before start date.")
            return

        priority = self.priority_input.currentText()
        status = self.status_input.currentText()

        # task fields
        task = {
            "name": name,
            "start": start,
            "end": end,
            "priority": priority,
            "status": status
        }

        selected = self.task_list.currentRow()
        if selected >= 0:
            self.tasks[selected] = task
        else:
            self.tasks.append(task)

        self.update_task_list()
        self.draw_gantt_chart()
        self.clear_inputs()

    def edit_task(self):
        selected = self.task_list.currentRow()
        if selected < 0:
            QMessageBox.warning(self, "No Selection", "Select a task to edit.")
            return
        task = self.tasks[selected]
        self.name_input.setText(task["name"])
        self.start_date_input.setDate(QDate(task["start"].year, task["start"].month, task["start"].day))
        self.end_date_input.setDate(QDate(task["end"].year, task["end"].month, task["end"].day))
        self.priority_input.setCurrentText(task["priority"])
        self.status_input.setCurrentText(task["status"])

    def delete_task(self):
        selected = self.task_list.currentRow()
        if selected < 0:
            QMessageBox.warning(self, "No Selection", "Select a task to delete.")
            return
        self.tasks.pop(selected)
        self.update_task_list()
        self.draw_gantt_chart()
        self.clear_inputs()

    def clear_inputs(self):
        self.name_input.clear()
        self.gantt_name_input.clear()
        self.start_date_input.setDate(QDate.currentDate())
        self.end_date_input.setDate(QDate.currentDate())
        self.priority_input.setCurrentText("Medium")
        self.status_input.setCurrentText("Not Started")
        self.task_list.clearSelection()
        
    def on_rows_moved(self, parent, start, end, destination, row):
            if start == row or start + 1 == row:
                return  # Return nothing
            
            # Move the corresponding task in the internal list
            task = self.tasks.pop(start)
            if start < row:
                self.tasks.insert(row - 1, task)
            else:
                self.tasks.insert(row, task)

            # Redraw the Gantt chart to reflect the new order
            self.draw_gantt_chart()

    def update_task_list(self):
        self.task_list.clear()
        for task in self.tasks:
            self.task_list.addItem(f"{task['name']} ({task['start']} ‚Üí {task['end']})")

    def draw_gantt_chart(self):
        self.ax.clear()
        for i, task in enumerate(self.tasks):
            start = task["start"]
            end = task["end"]
            duration = (end - start).days + 1
            color = self.priority_color(task["priority"])
            label = f"{task['name']} ({task['status']})"
            self.ax.barh(i, duration, left=start, color=color, edgecolor='black')
            self.ax.text(start, i, label, va='center', ha='left', fontsize=8)
            
        # Tracking line for today's date
        today = datetime.today()
        
        # Set legend for Gantt Chart
        self.ax.axvline(today, color='red', linestyle='-', linewidth=2, label='High')
        self.ax.axvline(today, color='orange', linestyle='-', linewidth=2, label='Medium')
        self.ax.axvline(today, color='green', linestyle='-', linewidth=2, label='Low')
        self.ax.axvline(today, color='blue', linestyle='--', linewidth=2, label="Today")

        # Set legend location (now includes all axvlines)
        self.ax.legend(loc='upper right')   

        self.ax.set_yticks(range(len(self.tasks)))
        self.ax.set_yticklabels([task["name"] for task in self.tasks])
        self.ax.invert_yaxis()
        self.ax.set_xlabel("Date")
        title = self.gantt_name_input.text().strip() or "Project Gantt Chart"
        self.ax.set_title(title)
        self.figure.autofmt_xdate()
        self.canvas.draw()

    def export_chart(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export Chart as PNG", "", "PNG Files (*.png)")
        if path:
            self.figure.savefig(path)
            QMessageBox.information(self, "Exported", f"Gantt chart saved to:\n{path}")

    def save_to_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Save Tasks to CSV", "", "CSV Files (*.csv)")
        if path:
            df = pd.DataFrame(self.tasks)
            df.to_csv(path, index=False)
            QMessageBox.information(self, "Saved", f"Tasks saved to:\n{path}")

    def load_from_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Load Tasks from CSV", "", "CSV Files (*.csv)")
        if path:
            try:
                df = pd.read_csv(path, parse_dates=["start", "end"])
                self.tasks = df.to_dict(orient="records")
                self.update_task_list()
                self.draw_gantt_chart()
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to load CSV:\n{e}")

# Loop the application to run the main file
if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = GanttChartApp()
    window.show()
    sys.exit(app.exec_())
